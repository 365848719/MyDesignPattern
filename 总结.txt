26种设计模式大全(含java代码)


 /**
  * 适配器模式
 * 在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。
 * 一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。
 *
  */
  
  
  
  /**
  *  桥接模式
 *  在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？这就要使用桥接模式
 *
  */
  
  
  /**
  * 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 
  * 1 builder：为创建一个产品对象的各个部件指定抽象接口。
 * 2 ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并 提供一个检索产品的接口。 3
  *    Director：构造一个使用Builder接口的对象。 4
  * Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程
 * 包含定义组成部件的类，包括将这些部件装配成最终产品的接口。
 */
  
  
  /*
  *
  * 命令模式 “行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，
 * 这种无法抵御变化的紧耦合是不合适的。
 * 在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）
 * 
  * 1.降低对象之间的耦合度。 2.新的命令可以很容易地加入到系统中。 3.可以比较容易地设计一个组合命令。 4.调用同一方法实现不同的功能
 * 
  */
  
  
  
  /*
  *
  * 组合模式 组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。
 * 有时候又叫做部分-整体模式，
 * 它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。
 * 组合模式让你可以优化处理递归或分级数据结构
 * 。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的
 * :文件系统。文件系统由目录和文件组成
 * 。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构
 * ，那么你可以使用组合模式Composite。
 */
  
  
  /**
  * 组合模式 组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。
 * 有时候又叫做部分-整体模式，
 * 它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。
 * 组合模式让你可以优化处理递归或分级数据结构
 * 。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的
 * :文件系统。文件系统由目录和文件组成
 * 。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构
 * ，那么你可以使用组合模式Composite。
 */
  
  
  
  /*
  *
  *装饰模式
 *装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
 */
  
  
  
  /**
  * 解释器模式 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
 * 主要解决：对于一些固定文法构建一个解释句子的解释器。
 * 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子
 * 。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构件语法树，定义终结符与非终结符。
 */
  
  
  
  /**
  * 解释器模式 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
 * 主要解决：对于一些固定文法构建一个解释句子的解释器。
 * 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子
 * 。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 如何解决：构件语法树，定义终结符与非终结符。
 */
  
  
  /**
  * 外观模式
 * 外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。
 *
  */
  
  
  /**
  * 工厂模式 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。
 * 著名的Jive论坛,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A
  * a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，
 * 但会给你系统带来更大的可扩展性和尽量少的修改量。
 */
  
  
  
  /**
  * 工厂模式 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。著名的Jive论坛
 * ,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A
  * a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，
 * 但会给你系统带来更大的可扩展性和尽量少的修改量。
 */
  
  /**
  * 享元模式
 * 
  * 它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。
 * 通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。
 * 如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销的时候就可以考虑是否可以使用享元模式。
 * 例如,如果发现某个对象的生成了大量细粒度的实例，并且这些实例除了几个参数外基本是相同的
 * ，如果把那些共享参数移到类外面，在方法调用时将他们传递进来，就可以通过共享大幅度单个实例的数目。
 */
  
  
  /**
  * 责任链模式
 * 
  * 责任链模式是一种设计模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。
 * 发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。
 * 
  */
  
  
  
  
  /**
  * 责任链模式
 * 
  * 责任链模式是一种设计模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。
 * 发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。
 * 
  */
  
  
  
  /**
  * 中介者模式 Mediator模式也叫中介者模式，是由GoF提出的23种软件设计模式的一种。Mediator模式是行为模式之一，在Mediator模式中，
 * 类之间的交互行为被统一放在Mediator的对象中，对象通过Mediator对象同其他对象交互，Mediator对象起着控制器的作用。
 * 
  */
  
  
  /**
  * 备忘录模式 
  * 在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
 */
  
  
  
  
  /**
  * 观察者模式
 * 一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。
 * 此种模式通常被用来实现事件处理系统。
 */
  
  
  
  /**
  * 观察者模式
 * 一个目标物件管理所有相依于它的观察者物件，
 并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。
 * 此种模式通常被用来实现事件处理系统。
 */
  
  
  /**
  * 原型模式
 * 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
 */
  
  
  /**
  * 代理模式 
  * 真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。
 * (2).代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。 (3).高扩展性
 */
  
  
  
  
  /**
  * 抽象工厂模式 抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。
 * 抽象工厂模式可以向客户端提供一个接口
 * ，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型
 * 。因此，实际上系统所需要的，
 * 仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。
 */
  
  
  
  
  /**
  * 抽象工厂模式 抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。
 * 抽象工厂模式可以向客户端提供一个接口
 * ，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型
 * 。因此，实际上系统所需要的，
 * 仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。
 */
  
  
  
  /**
  * 单例模式
 *单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例
 */
  
  
  /**
  * 状态模式
 * 状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。
 */
  
  
  
  /**
  *策略模式 
  *策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
 */
  
  
  
  /**
  * 模板模式
 *  模板方法模式（Template Method
  * Pattern），定义一个操作中的算法骨架，而将一些实现步骤延迟到子类当中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
 * 模板方法模式是比较简单的一种设计模式
 * ，但是它却是代码复用的一项基本的技术，在类库中尤其重要，它遵循“抽象类应当拥有尽可能多的行为，应当拥有尽可能少的数据”的重构原则
 * 。作为模板的方法要定义在父类中，在方法的定义中使用到抽象方法，而只看父类的抽象方法是根本不知道怎样处理的，实际做具体处理的是子类，在子类中实现具体功能，
 * 因此不同的子类执行将会得出不同的实现结果，但是处理流程还是按照父类定制的方式。这就是模板方法的要义所在，制定算法骨架，让子类具体实现。
 */
  
  
  
  
  /**
  * 访问者模式
 * 
  * 1.Visitor 抽象访问者角色，为该对象结构中具体元素角色声明一个访问操作接口。该操作接口的名字和参数标识了发送访问请求给具体访问者的具体元素角色，
 * 这样访问者就可以通过该元素角色的特定接口直接访问它。 2.ConcreteVisitor.具体访问者角色，实现Visitor声明的接口。
 * 3.Element 定义一个接受访问操作(accept())，它以一个访问者(Visitor)作为参数。
 * 4.ConcreteElement具体元素，实现了抽象元素(Element)所定义的接受操作接口。
 * 5.ObjectStructure结构对象角色，这是使用访问者模式必备的角色。它具备以下特性
 * 能枚举它的元素；可以提供一个高层接口以允许访问者访问它的元素；如有需要，可以设计成一个复合对象或者一个聚集（如一个列表或无序集合）。
 * 
  * 1、 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
 * 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor模式使得你可以将相关的操作集中起来定义在一个类中。 
  * 3、 当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。
 * 4、定义对象结构的类很少改变，但经常需要在此结构上定义新的操作
 * 。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。
 */
  
  
   